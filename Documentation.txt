diag_catch([V, H], [V1, H1])
[V, H] - положение охотника по горизонтали и вертикали
[V1, H1] - положение лисы по горизонтали и вертикали

охотник выше лисы по вертикали, если V<V1
охотник ниже лисы по вертикали, если V>V1
охотник левее лисы по горизонталиали, если H<H1
охотник правее лисы по горизонталиали, если H>H1

vert_catch, hor_catch - лиса поймана, если у нее и охотника равны вертикали
или горизонтали соответственно

diag_catch - есть несколько положений охотника и лисы друг относительно
друга
1) охотник ниже по вертикали и левее по горизонтали, надо искать вверх и
вправо по диагнонали -  diag_catch_up_right
2) охотник ниже по вертикали и правее по горизонтали, надо искать вверх и
влево по диагнонали - diag_catch_up_left
3)  охотник выше по вертикали и левее по горизонтали, надо искать вниз и
вправо по диагнонали - diag_catch_down_right
4) охотник выше по вертикали и правее по горизонтали, надо искать вниз и
влево по диагнонали - diag_catch_down_left

; - оператор или

В catch посылаю координаты охотника и координаты расставленных лис и проверяю, встал ли он так,
чтобы лиса оказалась с ним на вертикали, горизонтали или диагонали


random_list(N, T, L) :-
    findall([X,Y], (between(1,N,_), random(0, T,X), random(0, T, Y)), L).

Список случайно расставленных лис: N - число лис, T - наибольшее значение координат по вертикали и
горизонтали для каждой лисы, L - список расставленных лис

Необходимо инициализировать стартовую позицию охотника, чтобы терм game_loop имел это  аргумент,
потому что без него была такая проблема с ветвлением - все что вычислялось до ";" было недоступно после нее,
а т.к. теперь позиция охотника - аргумент у терма, она стала доступна во всем его теле(конкретно для поиска лис вокруг,
в случае если на текущей позиции лису не поймали)

Еще один пример:
    remover(HunterPosition, ListOfFoxes, Result),
    Result = [] -> game_loop(0, 0, [], 0), !;
    remover(HunterPosition, ListOfFoxes, Result),

тут результат верхнего remover не доступен после ; поэтому приходится дублировать вызов с теми же аргументами

Если в какой-то клетке лиса поймана, то не нужно показывать, сколько лис пеленгуется вокруг. -> main
Считать сколько лис вокруг даже при поимке лисы -> alternative

Главная идея ветвления в game_loop - длина списка на входе != длине списка на выходе, если из списка лис удалось удалить лису, 
соответсвующую позиции охотника, сообщаем об этом, спрашиваем следующую позицию.
Если длина списка на входе == длине списка на выходе, то ничего не удалили, показываем сколько лис пеленгуется из текущей позиции,
спрашиваем следующую позицию

Условия в определении fox_iterations - чтобы не искать сколько лис пеленгуются из положения охотника, если его положение задано вне игрового поля
Для защиты:
1) Убрать отладочные writeln
2) Протестировать с разными данными
3) Уточнть как работает remover, помнить, что есть еще один, удаляющий не первое вхождение, ПОТЕСТИРОВАТЬ ИГРУ С НИМ